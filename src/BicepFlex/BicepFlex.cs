using System.Data;
using System.Reflection;
using BicepFlex.Tokens;
using BicepRunner;

namespace BicepFlex;

public class BicepFlex
{
    private readonly string _bicepRoot;
    private readonly string _bicepOutputPath;
    private readonly string? _referenceTypesAssembly;

    public BicepFlex(string bicepRoot, string bicepOutputPath, string? referenceTypesAssembly = null)
    {
        _bicepRoot = bicepRoot;
        _bicepOutputPath = bicepOutputPath;
        _referenceTypesAssembly = referenceTypesAssembly;
    }

    public async Task Process()
    {
        var classes = new List<(string filename, string contents)>();
        var parse = new BicepFileParser();

        var allMetaFiles = await Task.WhenAll(Directory.GetFiles(_bicepRoot, "*.bicep", SearchOption.AllDirectories)
            .Select(async f => parse.Parse(Path.GetRelativePath(_bicepRoot, f), await File.ReadAllLinesAsync(f))));

        var referenceTypeAssembly = _referenceTypesAssembly == null ? null : Assembly.LoadFile(_referenceTypesAssembly);
        var keepGoing = true;
        while (keepGoing)
        {
            var madeInferences = false;
            foreach (var file in allMetaFiles)
            {
                if (file.InferTypes(_bicepRoot, allMetaFiles, referenceTypeAssembly)) madeInferences = true;
            }

            //If we made some inferences, do another pass to see if we can make some more
            keepGoing = madeInferences;
        }

        foreach (var file in allMetaFiles)
        {
            classes.Add(($"{file.FileName.ToPascalCase()}.cs", GenerateBicepClass(file)));
        }

        await WriteCsFiles(classes.ToArray(), _bicepOutputPath);
    }

    static string GenerateBicepClass(BicepMetaFile file)
    {
        var inputs = file.Parameters;
        var outputs = file.Outputs;

        var pascalCaseName = Path.GetFileNameWithoutExtension(file.FileName).ToPascalCase();
        var baseClass = file.Scope == "resourceGroup"
            ? "BicepResourceGroupScopeTemplate"
            : "BicepSubscriptionScopeTemplate";
        
        var classTemplate = @$"
// THIS CODE WAS GENERATED BY A TOOL.
// PLEASE DO NOT ALTER IT.
// ALL CLASSES ARE DECLARED PARTIAL SO YOU CAN MODIFY BEHAVIOUR EXTERNALLY

using BicepRunner;

{(string.IsNullOrWhiteSpace(file.Directory) ? "" : $"namespace {file.Directory.ToPascalCase().Replace(Path.DirectorySeparatorChar, '.')};")}

{string.Join(Environment.NewLine, inputs.OfType<BicepEnumToken>().Select(et => $@"
public class {et.DotNetTypeName()} : BicepOptions {{
    private  {et.DotNetTypeName()}(string bicepValue): base(bicepValue) {{
    }}
{string.Join(Environment.NewLine, et.DotNetFriendlyTokens.Select(etv => $"    public static readonly {et.DotNetTypeName()} {etv.DotNetFriendlyName} = new (\"{etv.BicepValue}\");"))}
}}"))}

public partial class {pascalCaseName}Module : {baseClass}<{pascalCaseName}Module.{pascalCaseName}Output> {{
    public override string FileName => ""{file.FileName}"";
    public override string FileHash => ""{file.Hash}"";

{string.Join(Environment.NewLine, inputs.Select(x => @$"
    private {x.DotNetTypeName()} _{x.Name} = default!;
    public {x.DotNetTypeName()} {x.Name.ToPascalCase()} {{ get => this._{x.Name}; set {{ this._{x.Name} = value; }} }}
"))}

    public partial class {pascalCaseName}Output : BicepOutput {{
        {string.Join(Environment.NewLine, outputs.Select(x => @$"

        private {x.DotNetTypeName()} _{x.Name} = default!;
        public {x.DotNetTypeName()} {x.Name.ToPascalCase()} {{ get => this._{x.Name}; set {{ this._{x.Name} = value; }} }}"))}

        public {pascalCaseName}Output(Dictionary<string, object> outputs) {{
            base.SetProperties(outputs);
        }}
    }}

    public override Dictionary<string, object> BuildParameters() {{
        var dictionary = new Dictionary<string, object>();
{string.Join(Environment.NewLine, inputs.OfType<BicepEnumToken>().Select(x => @$"        dictionary[""{x.Name}""] = new {{ value = this._{x.Name}.BicepValue}};"))}
{string.Join(Environment.NewLine, inputs.Except(inputs.OfType<BicepEnumToken>()).Select(x => @$"        dictionary[""{x.Name}""] = new {{ value = this._{x.Name}}};"))}
        return dictionary;
    }} 

    public override {pascalCaseName}Output BuildOutput(Dictionary<string, object> outputs) {{
        return new {pascalCaseName}Output(outputs);
    }} 
}}
";

        return classTemplate;
    }

    private async Task WriteCsFiles((string relativePath, string contents)[] classTemplates, string outputPath)
    {
        await Task.WhenAll(classTemplates.Select(f =>
        {
            var fullPath = Path.Combine(outputPath, f.relativePath);
            Directory.CreateDirectory(Path.GetDirectoryName(fullPath)!);
            return File.WriteAllTextAsync(fullPath, f.contents);
        }));
        Console.ForegroundColor = ConsoleColor.Green;
        Console.WriteLine($"Outputted files at {outputPath}");
        Console.ResetColor();
    }
}