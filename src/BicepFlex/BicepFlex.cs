using BicepParser;
using BicepParser.Tokens;

namespace BicepFlex;

public class BicepFlex
{
    private readonly string _bicepRoot;
    private readonly string _bicepOutputPath;
    private readonly string? _referenceTypesAssembly;

    public BicepFlex(string bicepRoot, string bicepOutputPath, string? referenceTypesAssembly = null)
    {
        _bicepRoot = bicepRoot;
        _bicepOutputPath = bicepOutputPath;
        _referenceTypesAssembly = referenceTypesAssembly;
    }

    public async Task Process()
    {
        var output = new BicepDirectoryTreeProcessor(_bicepRoot, _referenceTypesAssembly);
        var allMetaFiles = await output.Process();
        var classes = new List<(string filename, string contents)>();

        foreach (var file in allMetaFiles)
        {
            classes.Add(($"{file.FileName.ToPascalCase()}.cs", GenerateBicepClass(_bicepRoot, allMetaFiles, file)));
        }

        await WriteCsFiles(classes.ToArray(), _bicepOutputPath);
    }

    static string GenerateBicepClass(string bicepRoot, IEnumerable<BicepMetaFile> allFiles, BicepMetaFile file)
    {
        var inputs = file.Parameters;
        var outputs = file.Outputs;

        string GetNamespace(BicepMetaFile metaFile)
        {
            return metaFile.Directory!.ToPascalCase().Replace(Path.DirectorySeparatorChar, '.');
        }
        
        string GetTypeNameForModule(BicepMetaFile metaFile)
        {
            return $"{GetNamespace(metaFile)}.{Path.GetFileNameWithoutExtension(metaFile.FileName).ToPascalCase()}Module";
        }

        string GetTypeNameForReference(BicepModuleReferenceToken token)
        {
            Console.WriteLine($"Looking for file {token.ReferencedFileName}");
            var metaFile = allFiles.Single(x => x.FileName == token.ReferencedFileName);
            return GetTypeNameForModule(metaFile);
        }

        var pascalCaseName =  Path.GetFileNameWithoutExtension(file.FileName).ToPascalCase();
        
        var baseClass = file.Scope == "resourceGroup"
            ? "BicepResourceGroupScopeTemplate"
            : "BicepSubscriptionScopeTemplate";
        
        var classTemplate = @$"
// THIS CODE WAS GENERATED BY A TOOL.
// PLEASE DO NOT ALTER IT.
// ALL CLASSES ARE DECLARED PARTIAL SO YOU CAN MODIFY BEHAVIOUR EXTERNALLY

using BicepRunner;

{(string.IsNullOrWhiteSpace(file.Directory) ? "" : $"namespace {GetNamespace(file)};")}

{string.Join(Environment.NewLine, inputs.OfType<BicepEnumToken>().Select(et => $@"
public class {et.DotNetTypeName()} : BicepOptions {{
    private  {et.DotNetTypeName()}(string bicepValue): base(bicepValue) {{
    }}
{string.Join(Environment.NewLine, et.DotNetFriendlyTokens.Select(etv => $"    public static readonly {et.DotNetTypeName()} {etv.DotNetFriendlyName} = new (\"{etv.BicepValue}\");"))}
}}"))}

public partial class {pascalCaseName}Module : {baseClass}<{pascalCaseName}Module.{pascalCaseName}Output> {{
    public override string FileName => ""{file.FileName}"";
    public override string FileHash => ""{file.Hash}"";
    public override Type[] References =>  new Type [] {{ { string.Join($",{Environment.NewLine}", file.References.Select(x => $"typeof({GetTypeNameForReference(x)})").Distinct())} }};
    public override Type[] ReferencedBy => new Type [] {{ { string.Join($",{Environment.NewLine}", file.ReferencedBy.Select(x => $"typeof({GetTypeNameForModule(x)})").Distinct())} }};

{string.Join(Environment.NewLine, inputs.Select(x => @$"
    private {x.DotNetTypeName()} _{x.Name} = default!;
    public {x.DotNetTypeName()} {x.Name.ToPascalCase()} {{ get => this._{x.Name}; set {{ this._{x.Name} = value; }} }}
"))}

    public partial class {pascalCaseName}Output : BicepOutput {{
        {string.Join(Environment.NewLine, outputs.Select(x => @$"

        private {x.DotNetTypeName()} _{x.Name} = default!;
        public {x.DotNetTypeName()} {x.Name.ToPascalCase()} {{ get => this._{x.Name}; set {{ this._{x.Name} = value; }} }}"))}

        public {pascalCaseName}Output(Dictionary<string, object> outputs) {{
            base.SetProperties(outputs);
        }}
    }}

    public override Dictionary<string, object> BuildParameters() {{
        var dictionary = new Dictionary<string, object>();
{string.Join(Environment.NewLine, inputs.OfType<BicepEnumToken>().Select(x => @$"        dictionary[""{x.Name}""] = new {{ value = this._{x.Name}.BicepValue}};"))}
{string.Join(Environment.NewLine, inputs.Except(inputs.OfType<BicepEnumToken>()).Where(x => x.BicepType == "resource").Select(x => @$"        dictionary[""{x.Name}""] = new {{ value = this._{x.Name}.ResourceId}};"))}
{string.Join(Environment.NewLine, inputs.Except(inputs.OfType<BicepEnumToken>()).Where(x => x.BicepType != "resource").Select(x => @$"        dictionary[""{x.Name}""] = new {{ value = this._{x.Name}}};"))}
        return dictionary;
    }} 

    public override {pascalCaseName}Output BuildOutput(Dictionary<string, object> outputs) {{
        return new {pascalCaseName}Output(outputs);
    }} 
}}
";

        return classTemplate;
    }

    private async Task WriteCsFiles((string relativePath, string contents)[] classTemplates, string outputPath)
    {
        await Task.WhenAll(classTemplates.Select(f =>
        {
            var fullPath = Path.Combine(outputPath, f.relativePath);
            Directory.CreateDirectory(Path.GetDirectoryName(fullPath)!);
            return File.WriteAllTextAsync(fullPath, f.contents);
        }));
        Console.ForegroundColor = ConsoleColor.Green;
        Console.WriteLine($"Outputted files at {outputPath}");
        Console.ResetColor();
    }
}